# README.md

**SCP:SL EXILED Plugin — SCP Abilities (Title + Ability Manager)**

This repository is a template EXILED plugin for SCP: Secret Laboratory that implements the SCP abilities you described (018, 207, O207, 268, 330, 500, 2176, 244, 1853, 1576, 1344, 127).

> **Important:** This is a complete project scaffold with source files. Some integration points are intentionally left as small TODOs because exact function names in the game API may vary depending on EXILED version. I used EXILED v3+ conventions. See EXILED docs for API details: https://github.com/Exiled-Team/EXILED.

---

## Repository structure (create these files in your GitHub repo)

```
scp-sl-exiled-plugin/
├── .gitignore
├── README.md
├── ScpAbilities.sln
├── ScpAbilities/                 <-- Visual Studio project folder
│   ├── ScpAbilities.csproj
│   ├── Plugin.cs
│   ├── Config.cs
│   ├── EventHandlers.cs
│   └── Abilities/                <-- ability-specific helpers
│       ├── BaseAbility.cs
│       ├── Scp018.cs
│       ├── Scp207.cs
│       └── Scp500.cs
└── LICENSE
```

---

## How to use

1. Install EXILED (see EXILED README) on your SCP:SL server.
2. Build this project with .NET SDK (this project targets .NET 6).
3. Place the generated DLL into your server's `Plugins` folder (or follow EXILED recommended install).
4. Configure abilities in `Config.cs` or by adding your own config system.
5. Restart the server.

> For persistent DB storage (one-time grants etc.), integrate SQLite or a small JSON file persistence.

---

## Notes about implementation

- This plugin uses EXILED event handlers to track role changes and player events and applies abilities through code.
- Some abilities require game-client effects (movement speed, AHP, ammo conversion). Where direct API calls to change specific in-game properties are needed, I added `// TODO` markers with guidance.
- The plugin focuses on role-based granting: when a player is assigned a special role or receives an ability via command, the plugin records the ability and applies effects.

---

# ScpAbilities.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <LangVersion>10.0</LangVersion>
    <AssemblyName>ScpAbilities</AssemblyName>
    <RootNamespace>ScpAbilities</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="EXILED" Version="3.5.0" />
  </ItemGroup>
</Project>
```

> Adjust the EXILED package version to match the server's EXILED version.

---

# Plugin.cs

```csharp
using System;
using Exiled.API.Features;
using Exiled.API.Interfaces;

namespace ScpAbilities
{
    public class Plugin : IPlugin
    {
        public string Name => "ScpAbilities";
        public string Author => "YourName";
        public Version Version => new Version(0, 1, 0);
        public Version RequiredExiledVersion => new Version(3, 0, 0);

        private EventHandlers handlers;

        public void OnEnabled()
        {
            handlers = new EventHandlers();
            handlers.RegisterEvents();
            Log.Info("ScpAbilities plugin enabled.");
        }

        public void OnDisabled()
        {
            if (handlers != null)
            {
                handlers.UnregisterEvents();
                handlers = null;
            }
            Log.Info("ScpAbilities plugin disabled.");
        }
    }
}
```

---

# Config.cs

```csharp
namespace ScpAbilities
{
    public class Config
    {
        // Basic toggles for ability behavior
        public bool EnableLogging { get; set; } = true;

        // Defaults for specific abilities
        public int Scp500_Count { get; set; } = 12; // default pills for SCP-500

        // You can expand this config to be loaded from YAML/JSON as needed
    }
}
```

---

# EventHandlers.cs

```csharp
using System;
using System.Collections.Generic;
using Exiled.API.Features;
using Exiled.Events.EventArgs;
using Exiled.Events.Handlers;
using Player = Exiled.API.Features.Player;

namespace ScpAbilities
{
    public class EventHandlers
    {
        // Track which users have which abilities
        // Key: user id, Value: set of ability keys
        private readonly Dictionary<string, HashSet<string>> playerAbilities = new();

        // One-time-given tracking
        private readonly HashSet<string> oneTimeGiven = new();

        public void RegisterEvents()
        {
            Player.ChangingRole += OnChangingRole;
            Player.Hurting += OnHurting;
            Player.Verified += OnVerified;
            Server.RoundStarted += OnRoundStarted;
            // Add other event subscriptions as needed
        }

        public void UnregisterEvents()
        {
            Player.ChangingRole -= OnChangingRole;
            Player.Hurting -= OnHurting;
            Player.Verified -= OnVerified;
            Server.RoundStarted -= OnRoundStarted;
        }

        private void OnRoundStarted()
        {
            // Reset per-round state if necessary
            playerAbilities.Clear();
            oneTimeGiven.Clear();
        }

        private void OnVerified(VerifiedEventArgs ev)
        {
            // Player just joined the round — apply persistent abilities if any
            var ply = ev.Player;
            if (playerAbilities.TryGetValue(ply.UserId, out var abilSet))
            {
                foreach (var abil in abilSet)
                {
                    ApplyAbility(ply, abil);
                }
            }
        }

        private void OnChangingRole(ChangingRoleEventArgs ev)
        {
            // If you want abilities to trigger when player becomes a certain role
            var ply = ev.Player;
            // Example: if someone becomes SCP-173 we could auto-give some item
            // For now, no automatic role-to-ability logic is added
        }

        private void OnHurting(HurtingEventArgs ev)
        {
            // Example: SCP-018 deals damage on collision — here we interpret "collision" as server Hurt events
            var attacker = ev.Attacker;
            if (attacker == null) return;

            if (HasAbility(attacker, "018"))
            {
                // If attacker has 018 and attacked via physical collision (not gun)
                // This is a heuristic — ensure proper checks for attack type
                // Increase damage a bit
                ev.Amount += 5.0f; // add flat damage
            }
        }

        // Public API to give an ability to a player
        public bool GiveAbility(Player ply, string abilityKey, bool oneTime = false)
        {
            var uid = ply.UserId;
            var oneKey = $"{uid}_{abilityKey}";
            if (oneTime && oneTimeGiven.Contains(oneKey)) return false;

            if (!playerAbilities.TryGetValue(uid, out var set))
            {
                set = new HashSet<string>();
                playerAbilities[uid] = set;
            }

            if (set.Contains(abilityKey)) return false;
            set.Add(abilityKey);

            if (oneTime) oneTimeGiven.Add(oneKey);

            ApplyAbility(ply, abilityKey);
            if (ConfigManager.PluginConfig.EnableLogging) Log.Info($"Given ability {abilityKey} to {ply.Nickname} ({uid})");
            return true;
        }

        public bool RemoveAbility(Player ply, string abilityKey)
        {
            var uid = ply.UserId;
            if (!playerAbilities.TryGetValue(uid, out var set)) return false;
            if (!set.Remove(abilityKey)) return false;

            RemoveAbilityEffects(ply, abilityKey);
            if (ConfigManager.PluginConfig.EnableLogging) Log.Info($"Removed ability {abilityKey} from {ply.Nickname} ({uid})");
            return true;
        }

        private bool HasAbility(Player ply, string abilityKey)
        {
            return playerAbilities.TryGetValue(ply.UserId, out var set) && set.Contains(abilityKey);
        }

        private void ApplyAbility(Player ply, string abilityKey)
        {
            switch (abilityKey)
            {
                case "018":
                    Scp018.Apply(ply);
                    break;
                case "207":
                    Scp207.Apply(ply);
                    break;
                case "O207":
                    Scp207.ApplyO(ply);
                    break;
                case "500":
                    Scp500.GivePills(ply, ConfigManager.PluginConfig.Scp500_Count);
                    break;
                case "2176":
                    // Typically an activated ability — mark as available
                    ply.Broadcast(5, "SCP-2176 charge ready. Use the activation command to trigger.");
                    break;

                // Add more cases for other SCPs; these will call into their helper classes
                default:
                    ply.Broadcast(5, $"Ability {abilityKey} registered.");
                    break;
            }
        }

        private void RemoveAbilityEffects(Player ply, string abilityKey)
        {
            switch (abilityKey)
            {
                case "018":
                    Scp018.Remove(ply);
                    break;
                case "207":
                    Scp207.Remove(ply);
                    break;
                case "500":
                    Scp500.Remove(ply);
                    break;
                default:
                    break;
            }
        }
    }
}
```

---

# Abilities/BaseAbility.cs

```csharp
using Exiled.API.Features;

namespace ScpAbilities.Abilities
{
    public abstract class BaseAbility
    {
        public abstract string Key { get; }
        public abstract void Apply(Player ply);
        public abstract void Remove(Player ply);
    }
}
```

---

# Abilities/Scp018.cs

```csharp
using Exiled.API.Features;

namespace ScpAbilities.Abilities
{
    // SCP-018: Jumping gives speed increase. Collisions deal damage.
    public static class Scp018
    {
        // Apply passive buffs
        public static void Apply(Player ply)
        {
            // TODO: Increase player's run/jump speed. EXILED doesn't provide a direct 'SetSpeed' in docs here —
            // Use the proper property or movement module from the EXILED API.
            // Example (pseudocode): ply.PlayerEffects.Add(new ReducedMovementEffect(...));

            ply.Broadcast(3, "SCP-018 effect active: jumping increases speed; collisions deal extra damage.");
        }

        public static void Remove(Player ply)
        {
            // TODO: Remove speed modifiers added in Apply
            ply.Broadcast(3, "SCP-018 effect removed.");
        }
    }
}
```

---

# Abilities/Scp207.cs

```csharp
using Exiled.API.Features;

namespace ScpAbilities.Abilities
{
    public static class Scp207
    {
        public static void Apply(Player ply)
        {
            // Increase mobility and decrease max HP
            // TODO: Use the proper API to change movement speed
            // Example: ply.MoveSpeed *= 1.25f; ply.MaxHealth -= 20;
            ply.Broadcast(4, "SCP-207 active: mobility up, max health reduced.");
        }

        public static void ApplyO(Player ply)
        {
            // O-SCP-207: slower but provides AHP (temporary HP)
            // TODO: Implement temp HP via the game's API (if available). Otherwise emulate by adding a damage absorb variable in EventHandlers.Hurting.
            ply.Broadcast(4, "O-SCP-207 active: speed reduced, temporary HP granted.");
        }

        public static void Remove(Player ply)
        {
            // Revert changes
            ply.Broadcast(3, "SCP-207 removed.");
        }
    }
}
```

---

# Abilities/Scp500.cs

```csharp
using Exiled.API.Features;
using System.Collections.Generic;

namespace ScpAbilities.Abilities
{
    public static class Scp500
    {
        // Track pill counts per player in memory
        private static readonly Dictionary<string, int> pillCounts = new();

        public static void GivePills(Player ply, int count)
        {
            pillCounts[ply.UserId] = count;
            ply.Broadcast(3, $"You received {count} SCP-500 pills. Use the command to consume or throw them.");
        }

        public static bool ConsumePill(Player ply)
        {
            if (!pillCounts.TryGetValue(ply.UserId, out var c) || c <= 0) return false;
            pillCounts[ply.UserId] = c - 1;

            // TODO: Heal the player using the appropriate API
            ply.Heal(30); // If Heal exists; otherwise use ply.Health += 30 with cap
            ply.Broadcast(2, $"You consumed an SCP-500 pill. Pills left: {pillCounts[ply.UserId]}");
            return true;
        }

        public static void Remove(Player ply)
        {
            pillCounts.Remove(ply.UserId);
            ply.Broadcast(2, "SCP-500 removed from you.");
        }
    }
}
```

---

# .gitignore

```
bin/
obj/
.vs/
*.user
*.suo
*.pdb
*.cache

# Publish output
PublishOutput/

# Rider/VSCode
.idea/
.vscode/
```

---

# LICENSE

```
MIT License

Copyright (c) 2025 YourName

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction...
```

---

## Final notes (what you should do next)

1. Create a new GitHub repository and push the file/folder structure above.
2. Open the project in Visual Studio / dotnet CLI, restore packages (EXILED) and build.
3. Implement the TODOs where I marked API-dependent calls (movement speed, temp HP, ammo conversion). Consult the EXILED docs for exact API surface: https://exiled-team.github.io/EXILED/ or EXILED GitHub repo.
4. If you'd like, I can now:
   - Fill in the exact API calls after you tell me which EXILED version you're running, or
   - Convert the plugin to include a simple JSON persistence file for one-time grants, or
   - Generate the full repository as multiple separate files (I provided the contents above) and help craft commit messages for your first GitHub push.


-- End of template
